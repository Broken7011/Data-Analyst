Relational Databases store data in tables(relations)
Data is organized into rows(record) and columns (fields)

Tables are related through keys
Ensures data integrity and reduces redundancy.


# KEY CONCEPTS
Tables: Core structure for data storage
Primary Key: Uniquely identifies a record
Foreign Key: Establishes relationships between tables
SQL: Structured query language for database operations

# Normalization
Normalization organizes data to minimize redundancy
1NF: Eliminates duplicate columns
2NF: Remove subsets of data in multiple rows
3NF: Ensure all attributes depend only on the primary Key

# Advantages of Relational Databases:
Data integrity and accuracy 
Flexibility in data retrieval 
Support for transactions and concurrency 
Scalability and performance 


# Data Types 
Numeric Types (eg: Integer , BIGINT, REAL)
   --> -32,768 to 32,767 *-> SMALL INT
   --> Integer -2,147,483,648 to 2,146,483,647)
   --> BigInt: very large integers
   --> DECIMAL / DOUBLE(floating point numbers )

Character Types ( CHAR,VARCHAR, TEXT)
Date/time Types ( TIMESTAMP, DATE)
Boolean Type
Geometric Types
JSON/JSONB
CutomTypes(user defined)

# UNDERSTANDING Schemas in PostgreSQL
Schemas are logical containers within a postgreSQL database:
allow organization of database objects( tables,views, functions etc)
Provide namespace management to avoid name conflicts 
Users can create and manage multiple schemas

# Difference between a schema and a database
In postgreSQL , the main difference between a schema and a database is that a schema is a structural
representation of the data within a database, while a database is a container that holds the schemas,
records, logs, and table constraints.

# Creating schemas and Tables
1. Create schema sales;
2. Create a table in the schema
 CREATE TABLE sales.orders (
      id SERIAL PRIMARY KEY,
      customer_name TEXT,
      total NUMERIC
);

CREATE TABLE public.employee (
  id serial NOT NULL,
  name character varying(100),
"position" character varying(50),
 salary numeric(10),
 hire_date date DEFAULT CURRENT_DATE,
PRIMARY KEY (id)
);

# FOR MODIFICATION
ALTER TABLE public.employees ADD COLUMN department VARCHAR(50);
ALTER TABLE public.employees RENAME COLUMN department TO dept;

# FOR DELETION OF A TABLE 
DROP TABLE employees 

# CREATE A TABLE for SALES
CREATE TABLE product_sales (
  sale_id SERIAL PRIMARY KEY,
  product_id INT NOT NULL,
  product_name VARCHAR(100) NOT NULL,
  sale_date DATE NOT NULL , 
  quantity_sold INT NOT NULL CHECK (quantity_sold >=0),
  unit_price DECIMAL(10,2) NOT NULL CHECK(unit_price >=0),
  total_amount AS (quantity_sold * unit_price) STORED
);

# INSERTING DATA INTO TABLE

INSERT INTO employees (name,position, salary)
VALUES ("Alice","Manager",75000),
        ("Smith","Developer",65000),
        ("Clare","Designer",55000);

# TO SEE AND VISUALISE THE DATA 
SELECT * FROM employees WHERE salary > 40000;

# UPDATE data in table

UPDATE employees SET salary = 70000 WHERE id=2;

# DELETE DATA

DELETE FROM employees WHERE id=2;

# GET UNIQUE DATA FROM THE TABLE

SELECT DISTINCT positions from employees;
 # distinct is the keyword

# COUNT function count number of rows or columns what to count
SELECT COUNT(*) AS total FROM employees;

# WHERE CLAUSE 
SELECT * FROM employees WHERE hire_date > '2024-12-07'
SELECT * FROM employees WHERE position = "Developer" AND salary > 60000;
SELECT * FROM employees WHERE salary BETWEEN 10000 AND 40000;

# ORDER BY position
SELECT * FROM employees ORDER BY position/column ASC/DESC ( by default ascending is there);

# LIMIT will limit the output from the queries
SELECT * FROM employees ORDER BY salary DESC LIMIT 2;

# USING OFFSET will ignore the that many records
SELECT * FROM employees order by salar DESC LIMIT 2 OFFSET 2; (will ignore first 2 records);

# FUNCTIONS: SUM AVG MAX MIN
SELECT SUM(salary) AS total_salary FROM employees WHERE position = "Developers";

# IF I WANT TO GROUP the salary as different different rows then GROUP BY position:

SELECT position,SUM(salary) as Total_salary FROM employees GROUP BY position;
SELECT position,AVG(salary) as avg_salary FROM employees GROUP BY position;
SELECT position,MIN(salary) as min_salary FROM employees GROUP BY position;
SELECT position,Max(salary) as max_salary FROM employees GROUP BY position;

# STRING AGGREGATOR is used to combine the results of column 
SELECT position, STRING_AGG(name,",") AS employee_names FROM employees GROUP BY position;

# COUNT THE unique values 
SELECT COUNT(DISTINCT position) AS uniue_positions FROM employees;

# IF YOU WANT TO APPLY FILTER AFTER GROUPING THEN HAVING CLAUSE

SELECT department, SUM(salary)  AS Total_salary FROM employees GROUP BY department HAVING SUM(salary) > 8500;

### JOINS 
> INNER JOIN: Returns only matching rows from both tables.
> LEFT JOIN (or LEFT OUTER JOIN): returns all rows from the left table and matching
rows from the right table.
> RIGHT JOIN (or RIGHT OUTER JOIN)L returns all rows from the right table and matching
rows from the left table
> FULL OUTER JOINL returns rows when there is a match in one of the tables
> CROSS JOIN: returns the cartesian product of the two tables;

SELECT * FROM employees e INNER JOIN customers c ON e.id = c.id
SELECT * FROM employees e LEFT JOIN customers c ON e.id = c.id
SELECT * FROM employees e RIGHT JOIN customers c ON e.id = c.id
SELECT * FROM employees e FULL OUTER JOIN customers c ON e.id = c.id

SELECT E1.name as empl_name , E2.name AS manager_name FROM employees E1 LEFT JOIN employees E2 ON
E1.manager_id = E2.id;

SELECT * FROM products CROSS JOIN colors;



## CONSTRAINTS
> CREATE TABLE users(
 user_id SERIAL PRIMARY KEY,
 name VARCHAR(100) NOT NULL,  ## It will make sure that no value will be null
 email VARCHAR(100) NOT NULL, ## here as well
 OR
 email VARCHAR(100) UNIQUE ## it will make sure that every value would be unique 
age INT
);

# FORIEGN KEY references from other table as reference
CREATE TABLE orders( 
  order_id SERIAL PRIMARY KEY,
  order_date DATE,
  cust_id INT,
  FOREIGN KEY(cust_id)
  REFERENCES customers(cust_id)
);

# CHECK make sure it does the thing within the range
CREATE TABLE employees(
  employee_id SERIAL PRIMARY KEY,
  name VARCHAR(100),
  age INT,
  salary DECIMAL(10,2),
  CHECK(age BETWEEN 18 AND 65), -- Age between 18-65
  CHECK(salary>0) --> Ensure salary above 0

# DEFAULT helps to make a default value  
CREATE TABLE employees(
   employee_id SERIAL PRIMARY KEY,
   name VARCHAR(100),
   status VARCHAR(20) DEFAULT 'active',
   created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP 

# LIKE WILDCARDS --> % , __ ,"A%"
# INDEX is a fast version of looking at the table 
CREATE INDEX idx_employee_name ON employees (name);


