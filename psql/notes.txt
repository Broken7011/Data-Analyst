Relational Databases store data in tables(relations)
Data is organized into rows(record) and columns (fields)

Tables are related through keys
Ensures data integrity and reduces redundancy.


# KEY CONCEPTS
Tables: Core structure for data storage
Primary Key: Uniquely identifies a record
Foreign Key: Establishes relationships between tables
SQL: Structured query language for database operations

# Normalization
Normalization organizes data to minimize redundancy
1NF: Eliminates duplicate columns
2NF: Remove subsets of data in multiple rows
3NF: Ensure all attributes depend only on the primary Key

# Advantages of Relational Databases:
Data integrity and accuracy 
Flexibility in data retrieval 
Support for transactions and concurrency 
Scalability and performance 


# Data Types 
Numeric Types (eg: Integer , BIGINT, REAL)
   --> -32,768 to 32,767 *-> SMALL INT
   --> Integer -2,147,483,648 to 2,146,483,647)
   --> BigInt: very large integers
   --> DECIMAL / DOUBLE(floating point numbers )

Character Types ( CHAR,VARCHAR, TEXT)
Date/time Types ( TIMESTAMP, DATE)
Boolean Type
Geometric Types
JSON/JSONB
CutomTypes(user defined)

# UNDERSTANDING Schemas in PostgreSQL
Schemas are logical containers within a postgreSQL database:
allow organization of database objects( tables,views, functions etc)
Provide namespace management to avoid name conflicts 
Users can create and manage multiple schemas

# Difference between a schema and a database
In postgreSQL , the main difference between a schema and a database is that a schema is a structural
representation of the data within a database, while a database is a container that holds the schemas,
records, logs, and table constraints.

# Creating schemas and Tables
1. Create schema sales;
2. Create a table in the schema
 CREATE TABLE sales.orders (
      id SERIAL PRIMARY KEY,
      customer_name TEXT,
      total NUMERIC
);

CREATE TABLE public.employee (
  id serial NOT NULL,
  name character varying(100),
"position" character varying(50),
 salary numeric(10),
 hire_date date DEFAULT CURRENT_DATE,
PRIMARY KEY (id)
);

# FOR MODIFICATION
ALTER TABLE public.employees ADD COLUMN department VARCHAR(50);
ALTER TABLE public.employees RENAME COLUMN department TO dept;

# FOR DELETION OF A TABLE 
DROP TABLE employees 

# CREATE A TABLE for SALES
CREATE TABLE product_sales (
  sale_id SERIAL PRIMARY KEY,
  product_id INT NOT NULL,
  product_name VARCHAR(100) NOT NULL,
  sale_date DATE NOT NULL , 
  quantity_sold INT NOT NULL CHECK (quantity_sold >=0),
  unit_price DECIMAL(10,2) NOT NULL CHECK(unit_price >=0),
  total_amount AS (quantity_sold * unit_price) STORED
);

# INSERTING DATA INTO TABLE

INSERT INTO employees (name,position, salary)
VALUES ("Alice","Manager",75000),
        ("Smith","Developer",65000),
        ("Clare","Designer",55000);

# TO SEE AND VISUALISE THE DATA 
SELECT * FROM employees WHERE salary > 40000;

# UPDATE data in table

UPDATE employees SET salary = 70000 WHERE id=2;

# DELETE DATA

DELETE FROM employees WHERE id=2;

# GET UNIQUE DATA FROM THE TABLE

SELECT DISTINCT positions from employees;
 # distinct is the keyword

# COUNT function count number of rows or columns what to count
SELECT COUNT(*) AS total FROM employees;

# WHERE CLAUSE 
SELECT * FROM employees WHERE hire_date > '2024-12-07'
SELECT * FROM employees WHERE position = "Developer" AND salary > 60000;
SELECT * FROM employees WHERE salary BETWEEN 10000 AND 40000;

# ORDER BY position
SELECT * FROM employees ORDER BY position/column ASC/DESC ( by default ascending is there);

# LIMIT will limit the output from the queries
SELECT * FROM employees ORDER BY salary DESC LIMIT 2;

# USING OFFSET will ignore the that many records
SELECT * FROM employees order by salar DESC LIMIT 2 OFFSET 2; (will ignore first 2 records);
