name = "John Doe" # variable
age= 30
is_student = false
# used to save data as memory block
# True/ False , 30 , 100.00 are type of data

Integer  --> number
Float -> decimal
String --> "Character"
List --> []
Tuple --> ()
Set  -- {}
dictionary -- key: value
Boolean == TRUE / FALSE

# TO CHECK TYPE OF DATA
num = 123
print(type(num))

# To typecast the data / forcing data into different type of data
str/int/float(_variable_name)

# STRINGS
greeting = "Hello World"
print(greeting[0]) --> Access characters in a string using indexing
print(len(greeting)) --> get the length of  a string
print(greeting + " " + name + "!" ) # hello world name!
print(greeting[7:12]) --> slicing a string output --> world
print(greeting.upper()) # output "HELLO WORLD!"
print(greeting.lower()) # output "hello world!"
# REPLACE a substring in a string print(greeting.replace("World","Universe"))


#ARITHMETIC OPERATORS
x + y
x - y
x * y
x / y
x // y
x % y
x ** y

## COMPARISON OPERATORS
a == b 
a != b
a < b
a > b
a <= b
a >= b

## LOGICAL OPERATORS
cond1 and Cond2  > both need to be true
cond2 or cond2   > either have to be true 
cond not true 

## MEMBERSHIP OPERATORS
lst = [10,20,30,40,50]
print(20 in lst) # true
print(60 not in lst) # true

if condition:
  # code to be executed if condition is TRUE
else:
  # code to be executed if condition is FALSE
example[[[[

x = 10
y = 20
if x > y :
   print("X is greater than y")
else:
  print("x is not greater than y")

# LOOP 
while condition is true:
i = 1
while i <=5:
    print(i)
    i = i + 1

# calculator 
i = 1
while i <=10:
  print(f"{num} X {i} = {num *i}")
  i = i + 1

## FOR LOOP
for i in range(1,10):
   print(i)

## NESTED LOOP
for i in range(1,3):
   for j in range(1,4):
         print(f"{i} X {j} = {i * j}")

# PROGRAM 
import random
random_number = random.randint(1,100) # generate a random number between 1 and 100
print("Guess the number between 1 and 100:")

while True:
  guess= int(input("Your guess:"))
  if guess == random_number:
       print("You won!!")
       break 
   elif guess < random_number:
        print("Too low")
   else:
       print("Too high")

## FUNCTION is a block of organized , reusable code that performs a specific task whenever we call
def function_name(arguments):
  return result

def add(a,b):
 result = a+b
 return result

sum = add(3,4)
print(sum) # output: 7
 
### OOPS

class Car:
   def __init__(self, make , model, year):
         self.make = make
         self.model = model
         self.year = year
   def start(self):
        print(f"{self.make} {self.model} started")
   def stop(self):
        print(f"{self.make} {self.model} stopped")

my_car = Car("toyota","Camry",2020)
my_car.start()
my_car.stop()


### INHERITANCE 

class Animal:
   def __init__(self,name, species):
     self.name = name
     self.species = species
   def make_sound(self):
      print("Some generic animal sound")

class Dog(Animal): # extending class Animal 
   def __init__(self,name, breed):
         Animal.__init__(self, name, species="Dog")
         self.breed = breed  # calling 
   def make_sound(self):
        print("Bark")

dog = Dog("Rocky","Labrador")
print(dog.name)
print(dog.species)


# POLYMORPHISM in python refers to the ability of objects of differnt classes to respond to the same method call with their own implementation.

class Animal:
   def make_sound(self):
     pass
class Dog(Animal):
    def make_sound(self):
         print("Bark")
class Cat(Animal):
    def make_sound(self):
         print("Meow")
class Bird(Animal):
      def make_sound(self):
           print("Chirp")
def make_animals_sound(animals):
      for animal in animals:
            animal.make_sound()
dog = Dog()
cat = Cat()
bird = Bird()

animals = [dog,cat, bird]
make_animals_sound(animals)

## ABSTRACT CLASS in python is a class that is meant to be used as a base class for other classes and can not be instantiated directly. it acts as a blueprint for creating other classes and provides a common interface for its derived classes.


from abc import ABC, abstractmethod

class Shape(ABC):
   @abstractmethod
   def area(self):
       pass
   @abstractmethod
   def perimeter(self):
       pass

class Square(shape):
         def __init__(self,side):
           self.side = side
         def area(self):
              return self.side * self.side

         def perimeter(self):
              return self.side *4 
square = Square(4)
print("Area: ", square.area())
print("Perimeter: ", square.perimeter())


# Encapsulation refers to the practice of wrapping data and behaviour within an object, making it inaccessible to external code. This protects the internal state of the object from being modified
by external code and helps to ensure the correct operation of the object.

class BankAccount:
        def __init__(self, balance):
               self._balance = balance
        def deposit(self,amount):
               self._balance +=amount

        def withDraw(self, amount):
            if self._balance >= amount:
                  self._balance -= amount
            else:
                  print("Insufficient funds")

